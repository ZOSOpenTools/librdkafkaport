diff --git a/src/rdkafka.c b/src/rdkafka.c
index 99d9c174..801ace3f 100644
--- a/src/rdkafka.c
+++ b/src/rdkafka.c
@@ -39,7 +39,10 @@
 #include <sys/types.h>
 #include <dirent.h>
 #endif
+#ifdef __MVS__
 
+#include "zos_tls.h"
+#endif
 #include "rdkafka_int.h"
 #include "rdkafka_msg.h"
 #include "rdkafka_broker.h"
@@ -94,7 +97,13 @@ int rd_kafka_global_cnt;
  * Last API error code, per thread.
  * Shared among all rd_kafka_t instances.
  */
+#ifdef __MVS__
+rd_kafka_resp_err_t *rd_kafka_last_error_code;
+pthread_key_t rd_kafka_last_error_code_key;
+int rd_kafka_last_error_code_key_s = 0;
+#else
 rd_kafka_resp_err_t RD_TLS rd_kafka_last_error_code;
+#endif
 
 
 /**
@@ -109,14 +118,34 @@ int rd_kafka_thread_cnt(void) {
 /**
  * Current thread's log name (TLS)
  */
+#ifdef __MVS__
+char *rd_kafka_thread_name = NULL;
+pthread_key_t rd_kafka_thread_name_key;
+int rd_kafka_thread_name_key_s = 0;
+size_t size_of_rd_kafka_thread_name = 64;
+#else
 char RD_TLS rd_kafka_thread_name[64] = "app";
+#endif
 
 void rd_kafka_set_thread_name(const char *fmt, ...) {
         va_list ap;
 
+#ifdef __MVS__
+	GET_KEY_VAL(rd_kafka_thread_name_key,rd_kafka_thread_name_key_s,rd_kafka_thread_name,(size_of_rd_kafka_thread_name *sizeof(char)))
+	if(rd_kafka_thread_name[0]==0)
+	{
+		strcpy(rd_kafka_thread_name,"app");
+		SET_KEY_VAL(rd_kafka_thread_name_key,rd_kafka_thread_name)
+	}
+#endif
+
         va_start(ap, fmt);
-        rd_vsnprintf(rd_kafka_thread_name, sizeof(rd_kafka_thread_name), fmt,
-                     ap);
+        #ifdef __MVS__
+        rd_vsnprintf(rd_kafka_thread_name, size_of_rd_kafka_thread_name, fmt, ap);
+	SET_KEY_VAL(rd_kafka_thread_name_key,rd_kafka_thread_name)
+#else
+        rd_vsnprintf(rd_kafka_thread_name, sizeof(rd_kafka_thread_name), fmt, ap);
+#endif
         va_end(ap);
 }
 
@@ -126,14 +155,33 @@ void rd_kafka_set_thread_name(const char *fmt, ...) {
  * Note the name must be 15 characters or less, because it is passed to
  * pthread_setname_np on Linux which imposes this limit.
  */
+#ifdef __MVS__
+char *rd_kafka_thread_sysname = NULL;
+pthread_key_t rd_kafka_thread_sysname_key;
+int rd_kafka_thread_sysname_key_s = 0;
+size_t size_of_rd_kafka_thread_sysname = 16;
+#else
 static char RD_TLS rd_kafka_thread_sysname[16] = "app";
+#endif
 
 void rd_kafka_set_thread_sysname(const char *fmt, ...) {
         va_list ap;
+#ifdef __MVS__
+	GET_KEY_VAL(rd_kafka_thread_sysname_key,rd_kafka_thread_sysname_key_s,rd_kafka_thread_sysname,(size_of_rd_kafka_thread_sysname *sizeof(char)))
+	if(rd_kafka_thread_sysname[0]==0)
+	{
+		strcpy(rd_kafka_thread_sysname,"app");
+		SET_KEY_VAL(rd_kafka_thread_sysname_key,rd_kafka_thread_sysname)
+	}
+#endif
 
         va_start(ap, fmt);
-        rd_vsnprintf(rd_kafka_thread_sysname, sizeof(rd_kafka_thread_sysname),
-                     fmt, ap);
+        #ifdef __MVS__
+        rd_vsnprintf(rd_kafka_thread_sysname,size_of_rd_kafka_thread_sysname ,fmt, ap);
+	SET_KEY_VAL(rd_kafka_thread_sysname_key,rd_kafka_thread_sysname)
+#else
+        rd_vsnprintf(rd_kafka_thread_sysname, sizeof(rd_kafka_thread_sysname), fmt, ap);
+#endif
         va_end(ap);
 
         thrd_setname(rd_kafka_thread_sysname);
@@ -293,6 +341,15 @@ void rd_kafka_log0(const rd_kafka_conf_t *conf,
         unsigned int elen = 0;
         unsigned int of   = 0;
 
+#ifdef __MVS__
+	GET_KEY_VAL(rd_kafka_thread_name_key,rd_kafka_thread_name_key_s,rd_kafka_thread_name,(size_of_rd_kafka_thread_name *sizeof(char)))
+	if(rd_kafka_thread_name[0]==0)
+	{
+		strcpy(rd_kafka_thread_name,"app");
+		SET_KEY_VAL(rd_kafka_thread_name_key,rd_kafka_thread_name)
+	}
+#endif
+
         if (level > conf->log_level)
                 return;
 
@@ -711,13 +768,26 @@ void rd_kafka_get_err_descs(const struct rd_kafka_err_desc **errdescs,
 
 
 const char *rd_kafka_err2str(rd_kafka_resp_err_t err) {
+#ifdef __MVS__
+	char *ret = NULL;
+	static pthread_key_t ret_key;
+	static int ret_key_s = 0;
+	size_t size_of_ret = 32;
+#else
         static RD_TLS char ret[32];
+#endif
         int idx = err - RD_KAFKA_RESP_ERR__BEGIN;
+GET_KEY_VAL(ret_key,ret_key_s,ret,size_of_ret*sizeof(char))
 
         if (unlikely(err <= RD_KAFKA_RESP_ERR__BEGIN ||
                      err >= RD_KAFKA_RESP_ERR_END_ALL ||
                      !rd_kafka_err_descs[idx].desc)) {
+#ifdef __MVS__
+                rd_snprintf(ret, size_of_ret, "Err-%i?", err);
+		SET_KEY_VAL(ret_key,ret)
+#else
                 rd_snprintf(ret, sizeof(ret), "Err-%i?", err);
+#endif
                 return ret;
         }
 
@@ -726,13 +796,26 @@ const char *rd_kafka_err2str(rd_kafka_resp_err_t err) {
 
 
 const char *rd_kafka_err2name(rd_kafka_resp_err_t err) {
+#ifdef __MVS__
+	char *ret = NULL;
+	static pthread_key_t ret_key;
+	static int ret_key_s = 0;
+	size_t size_of_ret = 32;
+	GET_KEY_VAL(ret_key,ret_key_s,ret,sizeof(ret))
+#else
         static RD_TLS char ret[32];
+#endif
         int idx = err - RD_KAFKA_RESP_ERR__BEGIN;
 
         if (unlikely(err <= RD_KAFKA_RESP_ERR__BEGIN ||
                      err >= RD_KAFKA_RESP_ERR_END_ALL ||
                      !rd_kafka_err_descs[idx].desc)) {
-                rd_snprintf(ret, sizeof(ret), "ERR_%i?", err);
+                #ifdef __MVS__
+                rd_snprintf(ret, size_of_ret, "Err-%i?", err);
+		SET_KEY_VAL(ret_key,ret)
+#else
+                rd_snprintf(ret, sizeof(ret), "Err-%i?", err);
+#endif
                 return ret;
         }
 
@@ -741,7 +824,12 @@ const char *rd_kafka_err2name(rd_kafka_resp_err_t err) {
 
 
 rd_kafka_resp_err_t rd_kafka_last_error(void) {
+#ifdef __MVS__
+	GET_KEY_VAL(rd_kafka_last_error_code_key,rd_kafka_last_error_code_key_s,rd_kafka_last_error_code,sizeof(rd_kafka_resp_err_t))
+        return *rd_kafka_last_error_code;
+#else
         return rd_kafka_last_error_code;
+#endif
 }
 
 
@@ -1144,8 +1232,12 @@ static void rd_kafka_destroy_internal(rd_kafka_t *rk) {
         /* Trigger any state-change waiters (which should check the
          * terminate flag whenever they wake up). */
         rd_kafka_brokers_broadcast_state_change(rk);
+#ifdef __MVS__
+        if (rk->rk_background.thread.__) {
+#else
 
         if (rk->rk_background.thread) {
+#endif
                 int res;
                 /* Send op to trigger queue/io wake-up.
                  * The op itself is (likely) ignored by the receiver. */
@@ -2609,7 +2701,11 @@ fail:
         if (rk->rk_conf.sasl.provider)
                 rd_kafka_sasl_term(rk);
 
+#ifdef __MVS__
+        if (rk->rk_background.thread.__) {
+#else
         if (rk->rk_background.thread) {
+#endif
                 int res;
                 thrd_join(rk->rk_background.thread, &res);
                 rd_kafka_q_destroy_owner(rk->rk_background.q);
@@ -3125,8 +3221,13 @@ rd_kafka_consume0(rd_kafka_t *rk, rd_kafka_q_t *rkq, int timeout_ms) {
 
         if (timeout_ms)
                 rd_kafka_app_poll_blocking(rk);
-
+#ifdef __MVS__
+        GET_KEY_VAL(rd_kafka_yield_thread_key,rd_kafka_yield_thread_key_s,rd_kafka_yield_thread_p,sizeof(int))
+        rd_kafka_yield_thread = 0;
+SET_KEY_VAL(rd_kafka_yield_thread_key,rd_kafka_yield_thread_p)
+#else
         rd_kafka_yield_thread = 0;
+#endif
         while ((
             rko = rd_kafka_q_pop(rkq, rd_timeout_remains_us(abs_timeout), 0))) {
                 rd_kafka_op_res_t res;
@@ -3908,6 +4009,9 @@ rd_kafka_op_res_t rd_kafka_poll_cb(rd_kafka_t *rk,
                         }
 
                         rd_kafka_msg_destroy(rk, rkm);
+#ifdef __MVS__
+                        GET_KEY_VAL(rd_kafka_yield_thread_key,rd_kafka_yield_thread_key_s,rd_kafka_yield_thread_p,sizeof(int))
+#endif
 
                         if (unlikely(rd_kafka_yield_thread)) {
                                 /* Callback called yield(),
@@ -4336,8 +4440,13 @@ rd_kafka_resp_err_t rd_kafka_flush(rd_kafka_t *rk, int timeout_ms) {
 
         if (rk->rk_type != RD_KAFKA_PRODUCER)
                 return RD_KAFKA_RESP_ERR__NOT_IMPLEMENTED;
-
+#ifdef __MVS__
+        GET_KEY_VAL(rd_kafka_yield_thread_key,rd_kafka_yield_thread_key_s,rd_kafka_yield_thread_p,sizeof(int))
         rd_kafka_yield_thread = 0;
+SET_KEY_VAL(rd_kafka_yield_thread_key,rd_kafka_yield_thread_p)
+#else
+        rd_kafka_yield_thread = 0;
+#endif
 
         /* Set flushing flag on the producer for the duration of the
          * flush() call. This tells producer_serve() that the linger.ms
@@ -4489,9 +4598,23 @@ rd_kafka_resp_err_t rd_kafka_purge(rd_kafka_t *rk, int purge_flags) {
 const char *rd_kafka_purge_flags2str(int flags) {
         static const char *names[] = {"queue", "inflight", "non-blocking",
                                       NULL};
+#ifdef __MVS__
+        char *ret;
+	static pthread_key_t ret_key;
+	static int ret_key_s = 0;
+	size_t size_of_ret = 64;
+	GET_KEY_VAL(ret_key,ret_key_s,ret,size_of_ret*sizeof(char))
+#else
         static RD_TLS char ret[64];
+#endif
 
+#ifdef __MVS__
+        rd_flags2str(ret, size_of_ret, names, flags);
+	SET_KEY_VAL(ret_key,ret);
+	return ret;
+#else
         return rd_flags2str(ret, sizeof(ret), names, flags);
+#endif
 }
 
 
@@ -4500,7 +4623,15 @@ int rd_kafka_version(void) {
 }
 
 const char *rd_kafka_version_str(void) {
+#ifdef __MVS__
+        char *ret = NULL;
+	static pthread_key_t ret_key;
+	static int ret_key_s = 0;
+	size_t size_of_ret = 128;
+	GET_KEY_VAL(ret_key,ret_key_s,ret,size_of_ret*sizeof(char))
+#else
         static RD_TLS char ret[128];
+#endif
         size_t of = 0, r;
 
         if (*ret)
@@ -4508,15 +4639,33 @@ const char *rd_kafka_version_str(void) {
 
 #ifdef LIBRDKAFKA_GIT_VERSION
         if (*LIBRDKAFKA_GIT_VERSION) {
+#ifdef __MVS__
+                of = rd_snprintf(ret, size_of_ret, "%s",
+                                 *LIBRDKAFKA_GIT_VERSION == 'v'
+                                     ? &LIBRDKAFKA_GIT_VERSION[1]
+                                     : LIBRDKAFKA_GIT_VERSION);
+                if (of > size_of_ret)
+                        of = size_of_ret;
+#else
                 of = rd_snprintf(ret, sizeof(ret), "%s",
                                  *LIBRDKAFKA_GIT_VERSION == 'v'
                                      ? &LIBRDKAFKA_GIT_VERSION[1]
                                      : LIBRDKAFKA_GIT_VERSION);
                 if (of > sizeof(ret))
                         of = sizeof(ret);
+#endif /*__MVS__*/
         }
 #endif
 
+#ifdef __MVS__
+#define _my_sprintf(...)                                                       \
+        do {                                                                   \
+                r = rd_snprintf(ret + of, size_of_ret - of, __VA_ARGS__);      \
+                if (r > size_of_ret - of)                                      \
+                        r = size_of_ret - of;                                  \
+                of += r;                                                       \
+        } while (0)
+#else
 #define _my_sprintf(...)                                                       \
         do {                                                                   \
                 r = rd_snprintf(ret + of, sizeof(ret) - of, __VA_ARGS__);      \
@@ -4524,6 +4673,7 @@ const char *rd_kafka_version_str(void) {
                         r = sizeof(ret) - of;                                  \
                 of += r;                                                       \
         } while (0)
+#endif
 
         if (of == 0) {
                 int ver  = rd_kafka_version();
@@ -4547,6 +4697,9 @@ const char *rd_kafka_version_str(void) {
 #if WITHOUT_OPTIMIZATION
         _my_sprintf("-O0");
 #endif
+#ifdef __MVS__
+	SET_KEY_VAL(ret_key,ret)
+#endif
 
         return ret;
 }
@@ -4984,7 +5137,7 @@ rd_bool_t rd_kafka_dir_is_empty(const char *path) {
 #else
         DIR *dir;
         struct dirent *d;
-#if defined(__sun)
+#if defined(__sun) || defined(__MVS__)
         struct stat st;
         int ret = 0;
 #endif
@@ -4998,7 +5151,7 @@ rd_bool_t rd_kafka_dir_is_empty(const char *path) {
                 if (!strcmp(d->d_name, ".") || !strcmp(d->d_name, ".."))
                         continue;
 
-#if defined(__sun)
+#if defined(__sun) || defined(__MVS__)
                 ret = stat(d->d_name, &st);
                 if (ret != 0) {
                         return rd_true;  // Can't be accessed
@@ -5113,4 +5266,4 @@ int64_t rd_kafka_Uuid_least_significant_bits(const rd_kafka_Uuid_t *uuid) {
 
 int64_t rd_kafka_Uuid_most_significant_bits(const rd_kafka_Uuid_t *uuid) {
         return uuid->most_significant_bits;
-}
\ No newline at end of file
+}

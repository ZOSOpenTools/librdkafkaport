diff --git a/src/rdkafka_ssl.c b/src/rdkafka_ssl.c
index 85f745cb..9d3605ab 100644
--- a/src/rdkafka_ssl.c
+++ b/src/rdkafka_ssl.c
@@ -36,7 +36,9 @@
 #include "rdkafka_int.h"
 #include "rdkafka_transport_int.h"
 #include "rdkafka_cert.h"
-
+#ifdef __MVS__
+#include "zos_tls.h"
+#endif
 #ifdef _WIN32
 #include <wincrypt.h>
 #pragma comment(lib, "crypt32.lib")
@@ -105,10 +107,20 @@ rd_kafka_transport_ssl_clear_error(rd_kafka_transport_t *rktrans) {
  *          if no error.
  */
 const char *rd_kafka_ssl_last_error_str(void) {
+#ifdef __MVS__
+	static pthread_key_t errstr_key;
+	static int errstr_key_s = 0;
+	char *errstr = NULL;
+	size_t size_of_errstr = 256;
+#else
         static RD_TLS char errstr[256];
+#endif
         unsigned long l;
         const char *file, *data, *func;
         int line, flags;
+#ifdef __MVS__
+	GET_KEY_VAL(errstr_key,errstr_key_s, errstr,sizeof(char)*size_of_errstr)
+#endif
 
 #if OPENSSL_VERSION_NUMBER >= 0x30000000
         l = ERR_peek_last_error_all(&file, &line, &func, &data, &flags);
@@ -119,12 +131,18 @@ const char *rd_kafka_ssl_last_error_str(void) {
 
         if (!l)
                 return "";
-
+#ifdef __MVS__
+        rd_snprintf(errstr, size_of_errstr, "%lu:%s:%s:%s:%d: %s", l,
+#else
         rd_snprintf(errstr, sizeof(errstr), "%lu:%s:%s:%s:%d: %s", l,
+#endif
                     ERR_lib_error_string(l), func, file, line,
                     ((flags & ERR_TXT_STRING) && data && *data)
                         ? data
                         : ERR_reason_error_string(l));
+#ifdef __MVS__
+	SET_KEY_VAL(errstr_key,errstr) 
+#endif
 
         return errstr;
 }
@@ -1772,6 +1790,8 @@ static RD_UNUSED unsigned long rd_kafka_transport_ssl_threadid_cb(void) {
          * and thread id, which means we can't use the
          * thrd_current() API that returns the handle. */
         return (unsigned long)GetCurrentThreadId();
+#elif __MVS__
+        return (unsigned long)(intptr_t)thrd_current().__;
 #else
         return (unsigned long)(intptr_t)thrd_current();
 #endif
